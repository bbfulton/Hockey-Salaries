---
title: "NHL Hockey Salary Analysis"
output: html_document
---

In professional sports, one of the biggest questions that management has to continually evaluate is whether or not the players they are investing in are providing tangible, measureable results.  This is a fundamental concept that plays an integral role in trade considerations, contract negotations, and many other aspects of team management.  While it's difficult to accurately determine a player's value to a team over the course of just one season (injuries, personnel changes, individual roles on the team, etc. vary from year to year), it is nevertheless useful for teams to gather performance metrics and compare their players' performance and salaries to those of other players around the league.  

In this project, I'll model NHL player salaries as a function of numerous statistical categories compiled over the course of the 2016-2017 regular season and use that information to examine just how much value each team got from it's collective playerbase.  

Loading required packages

```{r Packages}

require(keras)
require(caret)
require(xgboost)
require(plyr)
require(tidyverse)
require(ggplot2)
require(lubridate)
require(scales)
require(rvest)
require(onehot)

```

Loading in training and testing data and then temporarily combining them into one data.frame

```{r Loading data}

set.seed(314)
train <- read.csv("C:\\Users\\Bryan\\Google Drive\\Kaggle\\Hockey\\train.csv", stringsAsFactors = FALSE)
test.x <- read.csv("C:\\Users\\Bryan\\Google Drive\\Kaggle\\Hockey\\test.csv", stringsAsFactors = FALSE)
test.y <- read.csv("C:\\Users\\Bryan\\Google Drive\\Kaggle\\Hockey\\test_salaries.csv", stringsAsFactors = FALSE)
test <- cbind(test.y, test.x)
rm(test.x); rm(test.y)
all.players <- rbind(train, test)
rm(test); rm(train)

```

There is a lot of potentially significant information to gather from a player's date of birth.  Extracting age and month of birth from DOB.

```{r}

all.players$Born <- ymd(all.players$Born)
all.players <- all.players %>% mutate(exactage = time_length(as.duration(interval(all.players$Born, Sys.Date())), "year"),
                                      monthbirth = as.factor(month(all.players$Born)),
                                      yearbirth = as.numeric(year(all.players$Born))) %>% 
                               mutate(floorage = floor(exactage)) %>%
                               select(-City)

```

The state in which each player is from isn't applicable to every country.  Adding "INT" factor to those entries.

```{r Adding factor level}

all.players$Pr.St[all.players$Pr.St == ""] <- "INT"
all.players$Pr.St <- as.factor(all.players$Pr.St)

```

Some players are from countries from which where there are not many NHL players. We'll combine those countries under one factor heading.

```{r Combining less common factors}

low.pop <- c("AUT", "DEU", "DNK", "EST", "FRA", "GBR", "HRV", "ITA", "NOR", "SVN", "LVA", "SVK")
all.players <- all.players %>% mutate(Cntry = ifelse(Cntry %in% low.pop, "INT", Cntry),
                                      Nat = ifelse(Nat %in% low.pop, "INT", Cntry))

```

Converting other variables to factors

```{r Factorizing}

all.players$Cntry <- as.factor(all.players$Cntry)
all.players$Nat <- as.factor(all.players$Nat)

```

Creating additional factor levels to account for players who were undrafted

```{r Undrafted Players}

all.players$DftYr[is.na(all.players$DftYr)] <- 0
all.players$DftRd[is.na(all.players$DftRd)] <- 0
all.players$Ovrl[is.na(all.players$Ovrl)] <- max(all.players$Ovrl, na.rm = TRUE) + 1
temp.draft <- data.frame(year(all.players$Born), all.players$DftYr)
names(temp.draft) <- c("born", "draft")
temp.draft <- temp.draft[temp.draft$draft != 0,]
temp.draft <- apply(temp.draft, 2, as.numeric)
temp.draft <- round(aggregate(draft ~ born, data = temp.draft, mean))
mean.draft.age <- round(mean(temp.draft$draft - temp.draft$born)) + 1
all.players <- all.players %>% mutate(leagueyears = ifelse(DftYr == 0, (as.numeric(yearbirth) + mean.draft.age), (2017 - as.numeric(DftYr))),
                                      DftYr = as.numeric(DftYr),
                                      DftRd = as.numeric(DftRd))
rm(temp.draft)
all.players <- select(all.players, -Born)

```

Enfactoring (is that a word?) handedness

```{r Handedness}

all.players <- all.players %>% mutate(Hand = ifelse(Hand == "L", 1, 0))

```

Some players played multiple positions, so additional features have to be added to account for that.

```{r Multiple positions}

all.players <- all.players %>% mutate(numpos = str_count(Position, "/") + 1) %>%
                               separate(col = Position, 
                                        into = c("primpos", "secpos", "tertpos"), 
                                        sep = "/", 
                                        fill = "right")
all.players <- all.players %>% mutate(lwpos = ifelse(all.players$primpos == "LW" | 
                                                     all.players$secpos == "LW" | 
                                                     all.players$tertpos == "LW", 1, 0),
                                      rwpos = ifelse(all.players$primpos == "RW" | 
                                                     all.players$secpos == "RW" | 
                                                     all.players$tertpos == "RW", 1, 0),
                                      cpos = ifelse(all.players$primpos == "C" | 
                                                    all.players$secpos == "C" | 
                                                    all.players$tertpos == "C", 1, 0),
                                      dpos = ifelse(all.players$primpos == "D" | 
                                                    all.players$secpos == "D" | 
                                                    all.players$tertpos == "D", 1, 0))
all.players$lwpos[is.na(all.players$lwpos)] <- 0
all.players$rwpos[is.na(all.players$rwpos)] <- 0
all.players$cpos[is.na(all.players$cpos)] <- 0
all.players$dpos[is.na(all.players$dpos)] <- 0
all.players <- within(all.players, rm(primpos, secpos, tertpos))

```

The amount of money that teams can afford to spend on players is influenced by global and local factors.  Macroeconomic international considerations such as exchange rates, taxes, and so forth have historical relevance to salaries large and small.  Most NHL teams are based in the United States, but some are located in Canada; this is something that should be noted.

```{r Canadian Teams}

canadian.teams <- c("TOR", "VAN", "CGY", "WPG", "OTT", "MTL", "EDM")

```

Additionally, because of in-season trades, some players played for multiple teams over the course of the season.  

```{r Multiple teams}

all.players <- all.players %>% mutate(numteam = str_count(Team, "/") +1) %>%
                               separate(col = Team,
                                        into = c("team1", "team2"),
                                        sep = "/",
                                        extra = "drop",
                                        fill = "right") %>%
                               mutate(team2 = ifelse(is.na(team2), team1, team2)) %>%
                               mutate(team1can = ifelse(team1 %in% canadian.teams, 1, 0),
                                      team2can = ifelse(team2 %in% canadian.teams, 1, 0),
                                      team1 = as.factor(team1),
                                      team2 = as.factor(team2))

```

Combining name fields 

```{r Full names}

all.players <- all.players %>% mutate(fullname = paste(First.Name, Last.Name, sep = " ")) %>%
                               select(-First.Name, -Last.Name)

```

One intangible factor in determining a player's value to a team is in his ability to lead.  Team captainsand alternates are generally chosen because those players are the ones that other's look to for leadership.  The original data did not contain this information, so it had to be scraped from another site.

```{r Captains}

caps <- read_html("https://www.sporcle.com/games/Flyersfan16/2016-17-nhl-captain-and-alternate-captain-nationality")
caps <- rbind(caps %>% html_nodes("table") %>% .[[2]] %>% html_table(),
              caps %>% html_nodes("table") %>% .[[3]] %>% html_table(),
              caps %>% html_nodes("table") %>% .[[4]] %>% html_table())
caps <- select(caps, -Country)
names(caps) <- c("team", "name")
caps <- separate(caps, team, into = c("teamname", "type"), sep = ";")
caps$type <- trimws(caps$type)
all.players <- merge(all.players, caps, by.x = "fullname", by.y = "name", all.x = TRUE, all.y = FALSE)
all.players <- select(all.players, -teamname)
all.players$type <- as.numeric(gsub(".*a.*", 1, all.players$type))
all.players$type[is.na(all.players$type)] <- 0
rm(caps)

```

Converting several fields to 'numerical' data types

```{r Converting to numerical}

ints <- which(sapply(1:ncol(all.players), function(x) is.integer(all.players[,x])))
for (i in ints) {
      all.players[,i] <- as.numeric(all.players[,i])
}

```

Separating player names from data set

```{r Names}

p.names <- all.players$fullname
all.players <- select(all.players, -fullname, -Pr.St)

```

Indentifying and One-hotting factor variables.  But we'll save the original factor variable data in a separate table for use later.

```{r One hotting}

factor.vars <- which(sapply(1:ncol(all.players), function(x) class(all.players[,x])) == "factor")
factor.table <- all.players[,factor.vars]
oh <- onehot(all.players[,factor.vars], max_levels = 32)
oh.df <- as.data.frame(predict(oh, all.players))
all.players <- as.data.frame(cbind(all.players, oh.df))
all.players <- all.players[,-factor.vars]
rm(oh.df)

```

Imputing NA data with median values for each corresponding feature

```{r NA Data}

nas <- which(colSums(is.na(all.players)) > 0)
for (i in nas) {
        all.players[is.na(all.players[,i]),i] <- as.numeric(median(all.players[,i], na.rm = TRUE))
}

```

Removing highly correlated fields

```{r Correlation}

correl <- cor(all.players)
all.players <- all.players[,-findCorrelation(correl, cutoff = 0.90)]

```

Splitting data back into training and testing sets and separating results in preparation for scaling of features

```{r Splitting Data}

intrain <- createDataPartition(all.players$Salary, p = 0.7, list = FALSE)
test.set <- all.players[-intrain,]
train.set <- all.players[intrain,]
train.x <- select(train.set, -Salary)
train.y <- select(train.set, Salary)
test.x <- select(test.set, -Salary)
test.y <- select(test.set, Salary)

```

Scaling the data 

```{r Scaling}

to.be.scaled <- c(1:5,7:77,82)
train.x[,to.be.scaled] <- scale(train.x[,to.be.scaled])
test.x[,to.be.scaled] <- scale(test.x[,to.be.scaled])

```

Recombining datasets for use in random forest and boosted tree training algorithms

```{r Combining data}

tr <- cbind(train.x, train.y)
te <- cbind(test.x, test.y)

```

Creating random forest model

```{r Random Forest}

tg <- expand.grid(mtry = c(2,12,70,140))

rf <- train(Salary ~.,
            data = tr,
            tuneGrid = tg,
            method = "rf",
            ntrees = 1000,
            preProcess = NULL,
            trControl = trainControl(method = "cv"))

```

Computing root mean square error for random forest model

```{r Random Forest model error}

rf.predict <- predict(rf, newdata = te)
RMSE(rf.predict, te$Salary)  

```

Creating boosted tree model

```{r xgbTree}

tg <- expand.grid(nrounds = 500, 
                  max_depth = 150,
                  eta = c(0.005, 0.010, 0.015),
                  gamma = 0,
                  colsample_bytree = 0.7,
                  min_child_weight = 1,
                  subsample = 0.1)

xt <- train(Salary ~.,
            data = tr,
            method = "xgbTree",
            tuneGrid = tg,
            preProcess = NULL,
            trControl = trainControl(method = "cv"))

```

Computing root mean square error for boosted tree model

```{r Boosted tree error}

xt.predict <- predict(xt, te)
RMSE(xt.predict, te$Salary)

```

For the 2016-2017 NHL Season, the league minimum salary was $575,000, so any model predictions that indicate a salary below that amount should be altered.

```{r League minimum}

league.min <- min(te$Salary)

```

Creating a data.frame that compares both the random forest and boosted tree model

```{r Model combination}

ens <- data.frame(xt.predict, rf.predict, te$Salary)
ens <- ens %>% mutate(xt.predict = ifelse(xt.predict < league.min, league.min, xt.predict),
                      rf.predict = ifelse(rf.predict < league.min, league.min, rf.predict)) %>%
               mutate(xt.diff = abs(te.Salary - xt.predict),
                      rf.diff = abs(te.Salary - rf.predict)) %>%
               mutate(model.diff = abs(xt.diff - rf.diff),
                      closer.mod = ifelse(xt.diff < rf.diff, "xt", "rf"))

```

A quick plot comparing the two models. I was hoping to see an easily recognizable trend that would indicate that one model performed better on certain salary ranges compared to the other.  For the most part, that isn't true except on actual salaries just below $1M, where the random forest model more accurately predicted salaries on twice as many entries than the boosted tree model.

```{r Model histogram}

p <- ggplot(ens, aes(te.Salary)) + geom_histogram(bins = 60) 
p <- p + facet_wrap(~closer.mod) 
p <- p + scale_x_discrete(limits = c(seq(1e6,1.4e7, 1e6)), labels = comma)
p <- p + theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust = 1))
plot(p)

```

Another plot that compares the two predictive models.  The red line indicates the hypothetical points where the two models agree with each other.  Point size is relative to actual player salaries, so theoretically, the smaller points should appear to the left side of each graph and the larger points should appear further to the left.  As you can see, that's certainly not always the case.  

```{r Model Accuracy}

facet.names <- c('rf' = "Data where Random Forest model provided better prediction", 
                 'xt' = "Data where XGBTree model provided better prediction")

p <- ggplot(ens, aes(rf.predict, xt.predict)) + geom_point(color = log(ens$te.Salary/1e5), size = log(ens$te.Salary/5e5))
p <- p + facet_wrap(~closer.mod, labeller = as_labeller(facet.names))
p <- p + scale_x_discrete(limits = c(seq(1e6, 6e6, 1e6)), labels = comma)
p <- p + scale_y_discrete(limits = c(seq(1e6, 6e6, 1e6)), labels = comma)
p <- p + theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust = 1))
p <- p + geom_abline(intercept = 0, slope = 1, color = "red")
p <- p + xlab("Random Forest Model Prediction") + ylab("Boosted Tree Model Prediction") 
p <- p + ggtitle("Plotting Random Forest vs Boosted Tree Predictions")
p <- p + theme(plot.title = element_text(hjust = 0.5))
plot(p)

```

Using the models to re-predict the entire dataset. There will obviously be a fair bit of overfitting here, but it should at least provide a somewhat reasonable result.  Ideally, this would not happen.  However, given the lack of data for additional years, this is the best that can be done for an entire season analysis.

```{r Bad data science here!}

tetr <- data.frame(rbind(te,tr))
tetr <- tetr[order(as.numeric(row.names(tetr))),]
names(tetr) <- names(tr)
all.xt.predict <- predict(xt, tetr)
all.rf.predict <- predict(rf, tetr)

```

Aggregating total team salaries and predicted salaries based on performance metrics.  For players who were traded during the course of the season, their projected and actual salaries were halved and those values were applied to both teams they played for.

```{r Prediction aggregates}

tetr <- as.data.frame(cbind(tetr, factor.table$team1, factor.table$team2))
names(tetr) <- c(names(tr), "team1", "team2")
predict.roster <- data.frame(cbind(tetr[,c("team1", "team2", "numteam", "Salary")], all.xt.predict, all.rf.predict))
predict.roster <- predict.roster %>% mutate(all.xt.predict = ifelse(numteam > 1, all.xt.predict/2, all.xt.predict),
                                            all.rf.predict = ifelse(numteam > 1, all.rf.predict/2, all.rf.predict),
                                            Salary = ifelse(numteam > 1, Salary/2, Salary)) %>%
                                     select(-numteam)
bp.roster <- select(predict.roster, -team2)
ep.roster <- select(predict.roster, -team1)
names(bp.roster) <- names(ep.roster) <- c("team", "Salary", "all.xt.predict", "all.rf.predict")
predict.roster <- unique(rbind(bp.roster, ep.roster))
predict.roster <- aggregate(.~team, data = predict.roster, FUN = sum)

```

Ultimately, the goal of each team is to make the playoffs.  Creating a table that shows actual team salaries and projected salaries and labels teams that made the playoffs.  Just how strongly does player value translate to playoff berths?

```{r Playoffs}

playoff.teams <- c("MTL", "NYR", "OTT", "BOS", "WSH", "TOR", "CBJ", "PIT", "CHI", "NSH", "MIN", "STL", "ANA", "CGY", "EDM", "S.J")

predict.roster <- predict.roster %>% mutate(xt.diff = all.xt.predict - Salary,
                                            rf.diff = all.rf.predict - Salary,
                                            playoffs = as.factor(ifelse(team %in% playoff.teams, "1", "0")))

```




